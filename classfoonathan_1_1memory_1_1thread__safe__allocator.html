<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: thread_safe_allocator&lt; RawAllocator, Mutex &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="namespacefoonathan_1_1memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefoonathan.html">foonathan</a></li><li class="navelem"><a class="el" href="namespacefoonathan_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classfoonathan_1_1memory_1_1thread__safe__allocator.html">thread_safe_allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Typedefs</a> &#124;
<a href="#pub-methods">Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">thread_safe_allocator&lt; RawAllocator, Mutex &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__storage.html">Allocator storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RawAllocator, class Mutex&gt;<br />
class foonathan::memory::thread_safe_allocator&lt; RawAllocator, Mutex &gt;</h3>

<p>An alias template for <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> using the <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">direct_storage</a> policy with a mutex. </p>
<p>It has a similar effect as <a class="el" href="classfoonathan_1_1memory_1_1allocator__adapter.html">allocator_adapter</a> but performs synchronization. The <code>Mutex</code> will default to <code>std::mutex</code> if threading is supported, otherwise there is no default. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abd368539d4750dc2ea909343eed521b2"><td class="memItemLeft" align="right" valign="top"><a id="abd368539d4750dc2ea909343eed521b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = typename StoragePolicy::allocator_type</td></tr>
<tr class="separator:abd368539d4750dc2ea909343eed521b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9615e22334e493ec6ef1f8588966cb2c"><td class="memItemLeft" align="right" valign="top"><a id="a9615e22334e493ec6ef1f8588966cb2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>storage_policy</b> = <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">direct_storage</a>&lt; RawAllocator &gt;</td></tr>
<tr class="separator:a9615e22334e493ec6ef1f8588966cb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a0dfdee0c83539ff9725f255c81ef"><td class="memItemLeft" align="right" valign="top"><a id="a4a7a0dfdee0c83539ff9725f255c81ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b> = Mutex</td></tr>
<tr class="separator:a4a7a0dfdee0c83539ff9725f255c81ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf829738ba45a0c47d96f529154baf0"><td class="memItemLeft" align="right" valign="top"><a id="aecf829738ba45a0c47d96f529154baf0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>is_stateful</b> = typename traits::is_stateful</td></tr>
<tr class="separator:aecf829738ba45a0c47d96f529154baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Member Functions</h2></td></tr>
<tr class="memitem:ac9c64316bb7697bc5b3cc48328369218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable</a> () const noexcept</td></tr>
<tr class="separator:ac9c64316bb7697bc5b3cc48328369218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa0774f4f3278b78aab48272657c8da07"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#aa0774f4f3278b78aab48272657c8da07">allocate_node</a> (std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:aa0774f4f3278b78aab48272657c8da07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b1b18b6b22f38918a3b9c9a9fae0b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate_array</b> (std::size_t count, std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:a715b1b18b6b22f38918a3b9c9a9fae0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c4c8201ed3a86738d5571239e19db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_node</b> (void *ptr, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:af39c4c8201ed3a86738d5571239e19db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f89da0a2dbd6ad5089178c828bb95df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_array</b> (void *ptr, std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a7f89da0a2dbd6ad5089178c828bb95df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64caa0912affaefd4778635a8a76294c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_node_size</b> () const</td></tr>
<tr class="separator:a64caa0912affaefd4778635a8a76294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f877acb00d33a3725a41c767152a5c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_array_size</b> () const</td></tr>
<tr class="separator:a62f877acb00d33a3725a41c767152a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e724b99fe1eb9b9a986a993da27b3b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_alignment</b> () const</td></tr>
<tr class="separator:a43e724b99fe1eb9b9a986a993da27b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a592316c791828db1554c8152dbb512e0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a592316c791828db1554c8152dbb512e0">try_allocate_node</a> (std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a592316c791828db1554c8152dbb512e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1db4f3c7901fb7654a12b28704337d2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><b>try_allocate_array</b> (std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:ae1db4f3c7901fb7654a12b28704337d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c9e0f5870c99a1accc9f3584b5204e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>try_deallocate_node</b> (void *ptr, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:ae6c9e0f5870c99a1accc9f3584b5204e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351b4f545a9cd775cee55a641ed41487"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>try_deallocate_array</b> (void *ptr, std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a351b4f545a9cd775cee55a641ed41487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad0e22f6844a93ca183a896dc1e863a50"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ad0e22f6844a93ca183a896dc1e863a50">get_allocator</a> () noexcept -&gt; decltype(std::declval&lt; <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">storage_policy</a> &gt;().get_allocator())</td></tr>
<tr class="separator:ad0e22f6844a93ca183a896dc1e863a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a06e20d6de45e38d0ba1b5530e39be"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const noexcept -&gt; decltype(std::declval&lt; const <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">storage_policy</a> &gt;().get_allocator())</td></tr>
<tr class="separator:a41a06e20d6de45e38d0ba1b5530e39be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70340fa1e8b36309bab2e07a334c35d7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a70340fa1e8b36309bab2e07a334c35d7">lock</a> () noexcept -&gt; FOONATHAN_IMPL_DEFINED(decltype(detail::lock_allocator(std::declval&lt; <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">storage_policy</a> &gt;().<a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ad0e22f6844a93ca183a896dc1e863a50">get_allocator</a>(), std::declval&lt; actual_mutex &amp; &gt;())))</td></tr>
<tr class="separator:a70340fa1e8b36309bab2e07a334c35d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b6521dd63f476505204524cec626ce"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>lock</b> () const noexcept -&gt; FOONATHAN_IMPL_DEFINED(decltype(detail::lock_allocator(std::declval&lt; const <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">storage_policy</a> &gt;().<a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ad0e22f6844a93ca183a896dc1e863a50">get_allocator</a>(), std::declval&lt; actual_mutex &amp; &gt;())))</td></tr>
<tr class="separator:af9b6521dd63f476505204524cec626ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa0774f4f3278b78aab48272657c8da07"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#aa0774f4f3278b78aab48272657c8da07">allocate_node</a> (std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:aa0774f4f3278b78aab48272657c8da07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b1b18b6b22f38918a3b9c9a9fae0b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate_array</b> (std::size_t count, std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:a715b1b18b6b22f38918a3b9c9a9fae0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c4c8201ed3a86738d5571239e19db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_node</b> (void *ptr, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:af39c4c8201ed3a86738d5571239e19db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f89da0a2dbd6ad5089178c828bb95df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_array</b> (void *ptr, std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a7f89da0a2dbd6ad5089178c828bb95df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64caa0912affaefd4778635a8a76294c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_node_size</b> () const</td></tr>
<tr class="separator:a64caa0912affaefd4778635a8a76294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f877acb00d33a3725a41c767152a5c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_array_size</b> () const</td></tr>
<tr class="separator:a62f877acb00d33a3725a41c767152a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e724b99fe1eb9b9a986a993da27b3b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_alignment</b> () const</td></tr>
<tr class="separator:a43e724b99fe1eb9b9a986a993da27b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a592316c791828db1554c8152dbb512e0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a592316c791828db1554c8152dbb512e0">try_allocate_node</a> (std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a592316c791828db1554c8152dbb512e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1db4f3c7901fb7654a12b28704337d2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><b>try_allocate_array</b> (std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:ae1db4f3c7901fb7654a12b28704337d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c9e0f5870c99a1accc9f3584b5204e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>try_deallocate_node</b> (void *ptr, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:ae6c9e0f5870c99a1accc9f3584b5204e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351b4f545a9cd775cee55a641ed41487"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>try_deallocate_array</b> (void *ptr, std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a351b4f545a9cd775cee55a641ed41487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad0e22f6844a93ca183a896dc1e863a50"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ad0e22f6844a93ca183a896dc1e863a50">get_allocator</a> () noexcept -&gt; decltype(std::declval&lt; <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">storage_policy</a> &gt;().get_allocator())</td></tr>
<tr class="separator:ad0e22f6844a93ca183a896dc1e863a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a06e20d6de45e38d0ba1b5530e39be"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const noexcept -&gt; decltype(std::declval&lt; const <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">storage_policy</a> &gt;().get_allocator())</td></tr>
<tr class="separator:a41a06e20d6de45e38d0ba1b5530e39be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70340fa1e8b36309bab2e07a334c35d7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a70340fa1e8b36309bab2e07a334c35d7">lock</a> () noexcept -&gt; FOONATHAN_IMPL_DEFINED(decltype(detail::lock_allocator(std::declval&lt; <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">storage_policy</a> &gt;().<a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ad0e22f6844a93ca183a896dc1e863a50">get_allocator</a>(), std::declval&lt; actual_mutex &amp; &gt;())))</td></tr>
<tr class="separator:a70340fa1e8b36309bab2e07a334c35d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b6521dd63f476505204524cec626ce"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>lock</b> () const noexcept -&gt; FOONATHAN_IMPL_DEFINED(decltype(detail::lock_allocator(std::declval&lt; const <a class="el" href="classfoonathan_1_1memory_1_1direct__storage.html">storage_policy</a> &gt;().<a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ad0e22f6844a93ca183a896dc1e863a50">get_allocator</a>(), std::declval&lt; actual_mutex &amp; &gt;())))</td></tr>
<tr class="separator:af9b6521dd63f476505204524cec626ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr class="memitem:a61e71d2d611c906a547cc9565f9a00d7"><td class="memTemplParams" colspan="2">template&lt;class Mutex , class RawAllocator &gt; </td></tr>
<tr class="memitem:a61e71d2d611c906a547cc9565f9a00d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1thread__safe__allocator.html#a61e71d2d611c906a547cc9565f9a00d7">make_thread_safe_allocator</a> (RawAllocator &amp;&amp;allocator) -&gt; <a class="el" href="classfoonathan_1_1memory_1_1thread__safe__allocator.html">thread_safe_allocator</a>&lt; typename std::decay&lt; RawAllocator &gt;::type, Mutex &gt;</td></tr>
<tr class="separator:a61e71d2d611c906a547cc9565f9a00d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Functions</h2>
<a id="aa0774f4f3278b78aab48272657c8da07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0774f4f3278b78aab48272657c8da07">&#9670;&nbsp;</a></span>allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a715b1b18b6b22f38918a3b9c9a9fae0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715b1b18b6b22f38918a3b9c9a9fae0b">&#9670;&nbsp;</a></span>allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="af39c4c8201ed3a86738d5571239e19db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39c4c8201ed3a86738d5571239e19db">&#9670;&nbsp;</a></span>deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a7f89da0a2dbd6ad5089178c828bb95df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f89da0a2dbd6ad5089178c828bb95df">&#9670;&nbsp;</a></span>deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a64caa0912affaefd4778635a8a76294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64caa0912affaefd4778635a8a76294c">&#9670;&nbsp;</a></span>max_node_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_node_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a62f877acb00d33a3725a41c767152a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f877acb00d33a3725a41c767152a5c">&#9670;&nbsp;</a></span>max_array_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_array_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a43e724b99fe1eb9b9a986a993da27b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e724b99fe1eb9b9a986a993da27b3b">&#9670;&nbsp;</a></span>max_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_alignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a592316c791828db1554c8152dbb512e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592316c791828db1554c8152dbb512e0">&#9670;&nbsp;</a></span>try_allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* try_allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd>The allocator must be composable, i.e. <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="ae1db4f3c7901fb7654a12b28704337d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1db4f3c7901fb7654a12b28704337d2">&#9670;&nbsp;</a></span>try_allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* try_allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd>The allocator must be composable, i.e. <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="ae6c9e0f5870c99a1accc9f3584b5204e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c9e0f5870c99a1accc9f3584b5204e">&#9670;&nbsp;</a></span>try_deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd>The allocator must be composable, i.e. <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="a351b4f545a9cd775cee55a641ed41487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351b4f545a9cd775cee55a641ed41487">&#9670;&nbsp;</a></span>try_deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd>The allocator must be composable, i.e. <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="ad0e22f6844a93ca183a896dc1e863a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e22f6844a93ca183a896dc1e863a50">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto get_allocator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Forwards to the <code>StoragePolicy</code>. </dd></dl>
<dl class="section user"><dt>Returns:</dt><dd>Returns a reference to the stored allocator. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This does not lock the <code>Mutex</code>. </dd></dl>

</div>
</div>
<a id="a41a06e20d6de45e38d0ba1b5530e39be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a06e20d6de45e38d0ba1b5530e39be">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto get_allocator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Forwards to the <code>StoragePolicy</code>. </dd></dl>
<dl class="section user"><dt>Returns:</dt><dd>Returns a reference to the stored allocator. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This does not lock the <code>Mutex</code>. </dd></dl>

</div>
</div>
<a id="a70340fa1e8b36309bab2e07a334c35d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70340fa1e8b36309bab2e07a334c35d7">&#9670;&nbsp;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:</dt><dd>A proxy object that acts like a pointer to the stored allocator. It cannot be reassigned to point to another allocator object and only moving is supported, which is destructive. As long as the proxy object lives and is not moved from, the <code>Mutex</code> will be kept locked. </dd></dl>

</div>
</div>
<a id="af9b6521dd63f476505204524cec626ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b6521dd63f476505204524cec626ce">&#9670;&nbsp;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:</dt><dd>A proxy object that acts like a pointer to the stored allocator. It cannot be reassigned to point to another allocator object and only moving is supported, which is destructive. As long as the proxy object lives and is not moved from, the <code>Mutex</code> will be kept locked. </dd></dl>

</div>
</div>
<a id="ac9c64316bb7697bc5b3cc48328369218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c64316bb7697bc5b3cc48328369218">&#9670;&nbsp;</a></span>is_composable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_composable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:</dt><dd>Whether or not the stored allocator is composable, that is you can use the compositioning functions. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to type-erased allocators, this function can not be <code>constexpr</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Related Functions</h2>
<a id="a61e71d2d611c906a547cc9565f9a00d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e71d2d611c906a547cc9565f9a00d7">&#9670;&nbsp;</a></span>make_thread_safe_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto make_thread_safe_allocator </td>
          <td>(</td>
          <td class="paramtype">RawAllocator &amp;&amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classfoonathan_1_1memory_1_1thread__safe__allocator.html">thread_safe_allocator</a>&lt;typename std::decay&lt;RawAllocator&gt;::type, Mutex&gt;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:</dt><dd>A new <a class="el" href="classfoonathan_1_1memory_1_1thread__safe__allocator.html">thread_safe_allocator</a> object created by forwarding to the constructor, specifying a certain mutex type. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd>It requires threading support from the implementation. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
