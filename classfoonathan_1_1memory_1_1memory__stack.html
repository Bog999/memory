<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: memory_stack&lt; BlockOrRawAllocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="group__memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefoonathan.html">foonathan</a></li><li class="navelem"><a class="el" href="namespacefoonathan_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html">memory_stack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Typedefs</a> &#124;
<a href="#pub-methods">Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">memory_stack&lt; BlockOrRawAllocator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__memory.html">memory</a> &#124; <a class="el" href="group__allocator.html">Allocator implementations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class BlockOrRawAllocator = default_allocator&gt;<br />
class foonathan::memory::memory_stack&lt; BlockOrRawAllocator &gt;</h3>

<p>A stateful <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a> that provides stack-like (LIFO) allocations. </p>
<p>It uses a <a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a> with a given <code>BlockOrRawAllocator</code> defaulting to <a class="el" href="classfoonathan_1_1memory_1_1growing__block__allocator.html">growing_block_allocator</a> to allocate huge blocks and saves a marker to the current top. Allocation simply moves this marker by the appropriate number of bytes and returns the pointer at the old marker position, deallocation is not directly supported, only setting the marker to a previously queried position. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7fd26a8539389ffa2a4b1d1a7b6b839c"><td class="memItemLeft" align="right" valign="top"><a id="a7fd26a8539389ffa2a4b1d1a7b6b839c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = <a class="el" href="group__core.html#gaf7651169a0cdd3612f5d8fc7baba505b">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt;</td></tr>
<tr class="separator:a7fd26a8539389ffa2a4b1d1a7b6b839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ce608b2537b1e273cb04fe657c78ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#ab6ce608b2537b1e273cb04fe657c78ea">marker</a> = implementation_defined</td></tr>
<tr class="memdesc:ab6ce608b2537b1e273cb04fe657c78ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The marker type that is used for unwinding.  <a href="classfoonathan_1_1memory_1_1memory__stack.html#ab6ce608b2537b1e273cb04fe657c78ea">More...</a><br /></td></tr>
<tr class="separator:ab6ce608b2537b1e273cb04fe657c78ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Member Functions</h2></td></tr>
<tr class="memitem:ab31c164183f69bc08896cfc4a8e5e8e7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab31c164183f69bc08896cfc4a8e5e8e7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#ab31c164183f69bc08896cfc4a8e5e8e7">memory_stack</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab31c164183f69bc08896cfc4a8e5e8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a97fd86cd1ca7b24d7853c737824bb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#a25a97fd86cd1ca7b24d7853c737824bb">allocate</a> (std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:a25a97fd86cd1ca7b24d7853c737824bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859a385b3dc6459e9b819334a2fd10ab"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#a859a385b3dc6459e9b819334a2fd10ab">try_allocate</a> (std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a859a385b3dc6459e9b819334a2fd10ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe61fb94b49aa0aaaadd752f052adbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#ab6ce608b2537b1e273cb04fe657c78ea">marker</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#aefe61fb94b49aa0aaaadd752f052adbe">top</a> () const noexcept</td></tr>
<tr class="separator:aefe61fb94b49aa0aaaadd752f052adbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f30af46c3d77066c680388109be2321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#a9f30af46c3d77066c680388109be2321">unwind</a> (<a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#ab6ce608b2537b1e273cb04fe657c78ea">marker</a> m) noexcept</td></tr>
<tr class="separator:a9f30af46c3d77066c680388109be2321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4af5032d71179d3abf04db463f791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#ad9e4af5032d71179d3abf04db463f791">shrink_to_fit</a> () noexcept</td></tr>
<tr class="separator:ad9e4af5032d71179d3abf04db463f791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97da77ca5a46e5e3088d6c0637b52af7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#a97da77ca5a46e5e3088d6c0637b52af7">capacity_left</a> () const noexcept</td></tr>
<tr class="separator:a97da77ca5a46e5e3088d6c0637b52af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fe037332aabd13253517d22394da73"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#af4fe037332aabd13253517d22394da73">next_capacity</a> () const noexcept</td></tr>
<tr class="separator:af4fe037332aabd13253517d22394da73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae445687ecb4a037b542ede5c6f48ac"><td class="memItemLeft" align="right" valign="top">allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#a3ae445687ecb4a037b542ede5c6f48ac">get_allocator</a> () noexcept</td></tr>
<tr class="separator:a3ae445687ecb4a037b542ede5c6f48ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedefs</h2>
<a id="ab6ce608b2537b1e273cb04fe657c78ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ce608b2537b1e273cb04fe657c78ea">&#9670;&nbsp;</a></span>marker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#ab6ce608b2537b1e273cb04fe657c78ea">marker</a> =  implementation_defined</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The marker type that is used for unwinding. </p>
<p>The exact type is implementation defined, it is only required that it is efficiently copyable and has all the comparision operators defined for two markers on the same stack. Two markers are equal, if they are copies or created from two <code>top()</code> calls without a call to <code>unwind()</code> or <code>allocate()</code>. A marker <code>a</code> is less than marker <code>b</code>, if after <code>a</code> was obtained, there was one or more call to <code>allocate()</code> and no call to <code>unwind()</code>. </p>

</div>
</div>
<h2 class="groupheader">Constructors</h2>
<a id="ab31c164183f69bc08896cfc4a8e5e8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31c164183f69bc08896cfc4a8e5e8e7">&#9670;&nbsp;</a></span>memory_stack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html">memory_stack</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:\n Creates it with a given initial block size and and other constructor arguments for the BlockAllocator.</dt><dd>It will allocate the first block and sets the top to its beginning. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Functions</h2>
<a id="a25a97fd86cd1ca7b24d7853c737824bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a97fd86cd1ca7b24d7853c737824bb">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:\n Allocates a memory block of given size and alignment.</dt><dd>It simply moves the top marker. If there is not enough space on the current memory block, a new one will be allocated by the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> or taken from a cache and used for the allocation. </dd></dl>
<dl class="section user"><dt>Returns:\n A node with given size and alignment.</dt><dd></dd></dl>
<dl class="section user"><dt>Throws:\n Anything thrown by the BlockAllocator on growth</dt><dd>or <a class="el" href="classfoonathan_1_1memory_1_1bad__allocation__size.html">bad_allocation_size</a> if <code>size</code> is too big. </dd></dl>
<dl class="section user"><dt>Requires:\n <code>size</code> and <code>alignment</code> must be valid. </dt><dd></dd></dl>

</div>
</div>
<a id="a859a385b3dc6459e9b819334a2fd10ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859a385b3dc6459e9b819334a2fd10ab">&#9670;&nbsp;</a></span>try_allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* try_allocate </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:\n Allocates a memory block of given size and alignment,</dt><dd>similar to <a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#a25a97fd86cd1ca7b24d7853c737824bb">allocate()</a>. But it does not attempt a growth if the arena is empty. </dd></dl>
<dl class="section user"><dt>Returns:\n A node with given size and alignment</dt><dd>or <code>nullptr</code> if there wasn't enough memory available. </dd></dl>

</div>
</div>
<a id="aefe61fb94b49aa0aaaadd752f052adbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe61fb94b49aa0aaaadd752f052adbe">&#9670;&nbsp;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#ab6ce608b2537b1e273cb04fe657c78ea">marker</a> top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:\n A marker to the current top of the stack.</dt><dd></dd></dl>

</div>
</div>
<a id="a9f30af46c3d77066c680388109be2321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f30af46c3d77066c680388109be2321">&#9670;&nbsp;</a></span>unwind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unwind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#ab6ce608b2537b1e273cb04fe657c78ea">marker</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:\n Unwinds the stack to a certain marker position.</dt><dd>This sets the top pointer of the stack to the position described by the marker and has the effect of deallocating all memory allocated since the marker was obtained. If any memory blocks are unused after the operation, they are not deallocated but put in a cache for later use, call <a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html#ad9e4af5032d71179d3abf04db463f791">shrink_to_fit()</a> to actually deallocate them. </dd></dl>
<dl class="section user"><dt>Requires:\n The marker must point to memory that is still in use and was the whole time,</dt><dd>i.e. it must have been pointed below the top at all time. </dd></dl>

</div>
</div>
<a id="ad9e4af5032d71179d3abf04db463f791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e4af5032d71179d3abf04db463f791">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:\n \ref unwind() does not actually do any deallocation of blocks on the BlockAllocator,</dt><dd>unused memory is stored in a cache for later reuse. This function clears that cache. </dd></dl>

</div>
</div>
<a id="a97da77ca5a46e5e3088d6c0637b52af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97da77ca5a46e5e3088d6c0637b52af7">&#9670;&nbsp;</a></span>capacity_left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t capacity_left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:\n The amount of memory remaining in the current block.</dt><dd>This is the number of bytes that are available for allocation before the cache or <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> needs to be used. </dd></dl>

</div>
</div>
<a id="af4fe037332aabd13253517d22394da73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fe037332aabd13253517d22394da73">&#9670;&nbsp;</a></span>next_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t next_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:\n The size of the next memory block after the current block is exhausted and the arena grows.</dt><dd>This function just forwards to the <a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>All of it is available for the stack to use, but due to fences and alignment buffers, this may not be the exact amount of memory usable for the user. </dd></dl>

</div>
</div>
<a id="a3ae445687ecb4a037b542ede5c6f48ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae445687ecb4a037b542ede5c6f48ac">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type&amp; get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:\n A reference to the BlockAllocator used for managing the arena.</dt><dd></dd></dl>
<dl class="section user"><dt>Requires:\n It is undefined behavior to move this allocator out into another object. </dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
